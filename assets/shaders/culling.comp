#version 430 core

// ============================================================================
// GPU Frustum Culling Compute Shader
// ============================================================================

// Instance data structure
struct InstanceData {
    vec3 position;
    vec3 rotation;
    vec3 scale;
    vec4 color;
    float textureIndex;
    float cullingRadius;
    float lodTransitionAlpha;
    float padding;
};

// Culling uniforms
layout(std140, binding = 0) uniform CullingUniforms {
    mat4 viewProjection;
    vec4 frustumPlanes[6];
    vec3 cameraPosition;
    uint totalInstances;
    uint baseIndexCount;
};

// Input/Output buffers
layout(std430, binding = 1) readonly buffer InstanceBuffer {
    InstanceData instances[];
};

layout(std430, binding = 2) writeonly buffer VisibleInstancesBuffer {
    uint visibleInstances[];
};

layout(std430, binding = 3) buffer InstanceCountBuffer {
    uint instanceCount;
};

// Local work group size
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Frustum visibility test
bool isVisible(vec3 center, float radius) {
    for (int i = 0; i < 6; i++) {
        vec4 plane = frustumPlanes[i];
        float distance = dot(plane.xyz, center) + plane.w;
        if (distance < -radius) {
            return false;
        }
    }
    return true;
}

void main() {
    uint id = gl_GlobalInvocationID.x;

    if (id >= totalInstances) {
        return;
    }

    InstanceData inst = instances[id];
    vec3 worldPos = inst.position;

    // Calculate bounding sphere radius
    float maxScale = max(max(inst.scale.x, inst.scale.y), inst.scale.z);
    float effectiveRadius = inst.cullingRadius * maxScale;

    // Frustum culling
    if (isVisible(worldPos, effectiveRadius)) {
        uint outputIndex = atomicAdd(instanceCount, 1);
        visibleInstances[outputIndex] = id;
    }
}
