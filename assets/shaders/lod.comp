#version 430 core

// ============================================================================
// GPU LOD Computation Shader
// ============================================================================

// Instance data structure
struct InstanceData {
    vec3 position;
    vec3 rotation;
    vec3 scale;
    vec4 color;
    float textureIndex;
    float cullingRadius;
    float lodTransitionAlpha;
    float padding;
};

// LOD uniforms
layout(std140, binding = 0) uniform LODUniforms {
    mat4 viewMatrix;
    mat4 projectionMatrix;
    vec3 cameraPosition;
    uint totalInstances;
    int viewportHeight;
    int lodMode;  // 0=distance, 1=screenspace, 2=hybrid
    float distanceHigh;
    float distanceMedium;
    float distanceCull;
    float screenspaceHigh;
    float screenspaceMedium;
    float screenspaceLow;
    float hybridWeight;
    vec4 frustumPlanes[6];
};

// Input/Output buffers
layout(std430, binding = 1) readonly buffer SourceInstancesBuffer {
    InstanceData sourceInstances[];
};

layout(std430, binding = 2) writeonly buffer LODAssignmentsBuffer {
    uint lodAssignments[];
};

layout(std430, binding = 3) buffer LODCountersBuffer {
    uint lodCounters[4];  // High, Medium, Low, Culled
};

layout(std430, binding = 4) writeonly buffer LODInstanceIndicesBuffer {
    uint lodInstanceIndices[];
};

// Local work group size
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Frustum visibility test
bool isVisible(vec3 center, float radius) {
    for (int i = 0; i < 6; i++) {
        vec4 plane = frustumPlanes[i];
        float distance = dot(plane.xyz, center) + plane.w;
        if (distance < -radius) {
            return false;
        }
    }
    return true;
}

// Calculate screen-space size
float calculateScreenSize(vec3 worldPos, float worldRadius) {
    // Transform to view space
    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);
    float distance = abs(viewPos.z);

    if (distance < 0.001) return 1.0;

    // Get FOV from projection matrix
    float fovYRad = 2.0 * atan(1.0 / projectionMatrix[1][1]);

    // Calculate screen-space size
    float sizeFraction = (worldRadius / distance) / tan(fovYRad * 0.5);

    return sizeFraction;
}

void main() {
    uint id = gl_GlobalInvocationID.x;

    if (id >= totalInstances) {
        return;
    }

    InstanceData inst = sourceInstances[id];
    vec3 worldPos = inst.position;

    // Calculate effective radius
    float maxScale = max(max(inst.scale.x, inst.scale.y), inst.scale.z);
    float effectiveRadius = inst.cullingRadius * maxScale;

    // Frustum culling first
    if (!isVisible(worldPos, effectiveRadius)) {
        lodAssignments[id] = 3;  // Culled
        atomicAdd(lodCounters[3], 1);
        return;
    }

    // Calculate distance and screen size
    float distance = length(worldPos - cameraPosition);
    float screenSize = calculateScreenSize(worldPos, effectiveRadius);

    // Determine LOD level
    uint lodLevel;

    if (lodMode == 0) {
        // Distance-based
        if (distance < distanceHigh) {
            lodLevel = 0;
        } else if (distance < distanceMedium) {
            lodLevel = 1;
        } else if (distance < distanceCull) {
            lodLevel = 2;
        } else {
            lodLevel = 3;
        }
    } else if (lodMode == 1) {
        // Screen-space based
        if (screenSize >= screenspaceHigh) {
            lodLevel = 0;
        } else if (screenSize >= screenspaceMedium) {
            lodLevel = 1;
        } else if (screenSize >= screenspaceLow) {
            lodLevel = 2;
        } else {
            lodLevel = 3;
        }
    } else {
        // Hybrid mode
        float distanceScore, screenspaceScore;

        if (distance < distanceHigh) {
            distanceScore = 0.0;
        } else if (distance < distanceMedium) {
            distanceScore = 1.0 + (distance - distanceHigh) /
                          (distanceMedium - distanceHigh);
        } else if (distance < distanceCull) {
            distanceScore = 2.0 + (distance - distanceMedium) /
                          (distanceCull - distanceMedium);
        } else {
            distanceScore = 3.0;
        }

        if (screenSize >= screenspaceHigh) {
            screenspaceScore = 0.0;
        } else if (screenSize >= screenspaceMedium) {
            screenspaceScore = 1.0 + (screenspaceHigh - screenSize) /
                            (screenspaceHigh - screenspaceMedium);
        } else if (screenSize >= screenspaceLow) {
            screenspaceScore = 2.0 + (screenspaceMedium - screenSize) /
                            (screenspaceMedium - screenspaceLow);
        } else {
            screenspaceScore = 3.0;
        }

        // Blend scores
        float finalScore = distanceScore * (1.0 - hybridWeight) +
                          screenspaceScore * hybridWeight;

        // Map to discrete LOD
        if (finalScore < 0.5) {
            lodLevel = 0;
        } else if (finalScore < 1.5) {
            lodLevel = 1;
        } else if (finalScore < 2.5) {
            lodLevel = 2;
        } else {
            lodLevel = 3;
        }
    }

    lodAssignments[id] = lodLevel;

    if (lodLevel < 3) {
        // Store instance index in LOD-specific buffer
        uint lodLocalIndex = atomicAdd(lodCounters[lodLevel], 1);
        uint baseOffset = lodLevel * totalInstances;
        lodInstanceIndices[baseOffset + lodLocalIndex] = id;
    } else {
        atomicAdd(lodCounters[3], 1);
    }
}
